{
  "version": 3,
  "sources": ["../bin/live-reload.js", "../node_modules/.pnpm/@finsweet+ts-utils@0.40.0/node_modules/@finsweet/ts-utils/dist/webflow/getPublishDate.js", "../src/utils/get-html-element.ts", "../src/features/wf-variable-mode-collector.ts"],
  "sourcesContent": ["new EventSource(`${SERVE_ORIGIN}/esbuild`).addEventListener(\"change\", () => location.reload());\n", "/**\n * Extracts the publish date of a Webflow site\n * @returns A Date object, if found.\n * @param page The page to get the publish date from. Defaults to the current page.\n */\nexport const getPublishDate = (page = document) => {\n    const publishDatePrefix = 'Last Published:';\n    for (const node of page.childNodes) {\n        if (node.nodeType === Node.COMMENT_NODE && node.textContent?.includes(publishDatePrefix)) {\n            const publishDateValue = node.textContent.trim().split(publishDatePrefix)[1];\n            if (publishDateValue)\n                return new Date(publishDateValue);\n        }\n    }\n};\n", "/**\r\n * Configuration options for HTML element selection utilities.\r\n */\r\ntype GetHtmlElementProps = {\r\n  /** CSS selector string to target the desired element(s) */\r\n  selector: string;\r\n  /** Optional parent element to scope the search within. Defaults to document if not provided */\r\n  parent?: HTMLElement;\r\n  /** Logging level for when elements are not found. Set to false to disable logging */\r\n  log?: \"debug\" | \"error\" | false;\r\n};\r\n\r\n/**\r\n * Safely retrieves a single HTML element using a CSS selector with optional logging.\r\n *\r\n * @template TElement - The specific HTML element type to return (extends HTMLElement)\r\n * @param options - Configuration object for element selection\r\n * @param options.selector - CSS selector string to target the desired element\r\n * @param options.parent - Optional parent element to scope the search within\r\n * @param options.log - Logging level when element is not found (\"debug\", \"error\", or false)\r\n * @returns The found HTML element cast to the specified type, or null if not found\r\n *\r\n * @example\r\n * ```typescript\r\n * // Get a button element with error logging\r\n * const button = getHtmlElement<HTMLButtonElement>({\r\n *   selector: '.submit-btn',\r\n *   log: 'error'\r\n * });\r\n *\r\n * // Get an element within a specific parent with debug logging\r\n * const input = getHtmlElement<HTMLInputElement>({\r\n *   selector: 'input[type=\"email\"]',\r\n *   parent: formElement,\r\n *   log: 'debug'\r\n * });\r\n *\r\n * // Silent mode - no logging\r\n * const element = getHtmlElement({\r\n *   selector: '.optional-element',\r\n *   log: false\r\n * });\r\n * ```\r\n */\r\nexport const getHtmlElement = <TElement extends HTMLElement = HTMLElement>({\r\n  selector,\r\n  parent,\r\n  log = \"debug\",\r\n}: GetHtmlElementProps): TElement | null => {\r\n  const targetElement = (parent || document).querySelector<TElement>(selector);\r\n\r\n  if (targetElement === null) {\r\n    if (log === false) return null;\r\n    const consoleMethod = log === \"debug\" ? console.debug : console.error;\r\n    consoleMethod(\r\n      `${log.toUpperCase()}: Element with selector \"${selector}\" not found in ${\r\n        parent !== undefined ? \"the specified parent element:\" : \"the document.\"\r\n      }`,\r\n      parent\r\n    );\r\n    return null;\r\n  }\r\n\r\n  return targetElement;\r\n};\r\n\r\n/**\r\n * Safely retrieves multiple HTML elements using a CSS selector with optional logging.\r\n *\r\n * @template TElement - The specific HTML element type for array items (extends HTMLElement)\r\n * @param options - Configuration object for element selection\r\n * @param options.selector - CSS selector string to target the desired elements\r\n * @param options.parent - Optional parent element to scope the search within\r\n * @param options.log - Logging level when no elements are found (\"debug\", \"error\", or false)\r\n * @returns Array of found HTML elements cast to the specified type, or null if none found\r\n *\r\n * @example\r\n * ```typescript\r\n * // Get all list items with debug logging\r\n * const listItems = getMultipleHtmlElements<HTMLLIElement>({\r\n *   selector: 'li.item',\r\n *   log: 'debug'\r\n * });\r\n *\r\n * // Get all inputs within a form with error logging\r\n * const inputs = getMultipleHtmlElements<HTMLInputElement>({\r\n *   selector: 'input',\r\n *   parent: formElement,\r\n *   log: 'error'\r\n * });\r\n *\r\n * // Silent mode - no logging when elements not found\r\n * const buttons = getMultipleHtmlElements<HTMLButtonElement>({\r\n *   selector: '.action-btn',\r\n *   log: false\r\n * });\r\n * ```\r\n */\r\nexport const getMultipleHtmlElements = <TElement extends HTMLElement = HTMLElement>({\r\n  selector,\r\n  parent,\r\n  log = \"debug\",\r\n}: GetHtmlElementProps): TElement[] | null => {\r\n  const targetElements = Array.from((parent || document).querySelectorAll<TElement>(selector));\r\n\r\n  if (targetElements.length === 0) {\r\n    if (log === false) return null;\r\n    const consoleMethod = log === \"debug\" ? console.debug : console.error;\r\n    consoleMethod(\r\n      `${log.toUpperCase()}: No elements found with selector \"${selector}\" in ${\r\n        parent !== undefined ? \"the specified parent element:\" : \"the document.\"\r\n      }`,\r\n      parent\r\n    );\r\n    return null;\r\n  }\r\n\r\n  return targetElements;\r\n};\r\n", "import { getPublishDate as getWfPublishDate } from \"@finsweet/ts-utils\";\r\n\r\nimport { getMultipleHtmlElements } from \"@/utils/get-html-element\";\r\n\r\n// Type definitions\r\ntype VariableModes = Record<string, Record<string, string>>;\r\n\r\ninterface CachedVariableModes {\r\n  publishDate: string;\r\n  data: VariableModes;\r\n}\r\n\r\n// Worker message types\r\ninterface WorkerFetchStylesheetRequest {\r\n  type: \"fetchStylesheet\";\r\n  url: string;\r\n}\r\n\r\ninterface WorkerFetchStylesheetResponse {\r\n  type: \"stylesheetProcessed\";\r\n  classRulesMap: Record<string, Record<string, string>>;\r\n  error?: string;\r\n}\r\n\r\nconst CACHE_KEY = \"webflow-variable-modes-cache\";\r\n\r\n// Create a worker from a function\r\nfunction createWorker(fn: () => void): Worker {\r\n  const blob = new Blob([`(${fn.toString()})()`], { type: \"application/javascript\" });\r\n  const url = URL.createObjectURL(blob);\r\n  const worker = new Worker(url);\r\n\r\n  // Clean up the URL\r\n  URL.revokeObjectURL(url);\r\n\r\n  return worker;\r\n}\r\n\r\n// Worker function that will be converted to a string\r\nfunction cssWorkerFunction() {\r\n  // Set up worker message handler\r\n  self.addEventListener(\"message\", async (event) => {\r\n    const msg = event.data;\r\n\r\n    if (msg.type === \"fetchStylesheet\") {\r\n      try {\r\n        // Fetch the stylesheet\r\n        const response = await fetch(msg.url);\r\n\r\n        if (!response.ok) {\r\n          throw new Error(`Failed to fetch stylesheet: ${response.status} ${response.statusText}`);\r\n        }\r\n\r\n        const cssText = await response.text();\r\n\r\n        // Parse the CSS text to find class selectors and their properties\r\n        const classRegex = /\\.([^\\s{,:]+)\\s*{([^}]*)}/g;\r\n        const classRulesMap: Record<string, Record<string, string>> = {};\r\n\r\n        let match;\r\n        while ((match = classRegex.exec(cssText)) !== null) {\r\n          const className = match[1];\r\n          const styleBlock = match[2];\r\n\r\n          if (!className || !styleBlock) continue;\r\n\r\n          // Extract CSS variables\r\n          const variableRegex = /(--[^:]+):\\s*([^;]+);/g;\r\n          let varMatch;\r\n          const customProps: Record<string, string> = {};\r\n\r\n          while ((varMatch = variableRegex.exec(styleBlock)) !== null) {\r\n            const propName = varMatch[1].trim();\r\n            const propValue = varMatch[2].trim();\r\n            customProps[propName] = propValue;\r\n          }\r\n\r\n          // Store the results if any CSS variables were found\r\n          if (Object.keys(customProps).length > 0) {\r\n            classRulesMap[className] = customProps;\r\n          }\r\n        }\r\n\r\n        // Send the results back to the main thread\r\n        self.postMessage({\r\n          type: \"stylesheetProcessed\",\r\n          classRulesMap,\r\n        });\r\n      } catch (e) {\r\n        self.postMessage({\r\n          type: \"stylesheetProcessed\",\r\n          classRulesMap: {},\r\n          error: e instanceof Error ? e.message : String(e),\r\n        });\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Extracts CSS custom properties using a web worker to avoid blocking the main thread.\r\n */\r\nasync function extractCssCustomProperties(\r\n  elements: HTMLElement[]\r\n): Promise<Map<HTMLElement, Record<string, string>>> {\r\n  // Initialize result map\r\n  const result = new Map<HTMLElement, Record<string, string>>();\r\n\r\n  // Find the first loaded stylesheet\r\n  const firstStylesheet = document.styleSheets[0];\r\n  if (!firstStylesheet || !firstStylesheet.href) {\r\n    return result;\r\n  }\r\n\r\n  // Get all class names from elements for efficient processing\r\n  const elementClassMap = new Map<string, HTMLElement[]>();\r\n\r\n  for (const element of elements) {\r\n    if (!element.classList.length) {\r\n      result.set(element, {});\r\n      continue;\r\n    }\r\n\r\n    const className = element.classList[0]!;\r\n\r\n    if (!elementClassMap.has(className)) {\r\n      elementClassMap.set(className, []);\r\n    }\r\n\r\n    elementClassMap.get(className)!.push(element);\r\n  }\r\n\r\n  // Create worker and set up message handling\r\n  const worker = createWorker(cssWorkerFunction);\r\n\r\n  try {\r\n    // Process the stylesheet in the worker\r\n    const classRulesMap = await new Promise<Record<string, Record<string, string>>>(\r\n      (resolve, reject) => {\r\n        worker.onmessage = (event) => {\r\n          const response = event.data as WorkerFetchStylesheetResponse;\r\n\r\n          if (response.type === \"stylesheetProcessed\") {\r\n            if (response.error) {\r\n              reject(new Error(response.error));\r\n            } else {\r\n              resolve(response.classRulesMap);\r\n            }\r\n          }\r\n        };\r\n\r\n        worker.onerror = (error) => {\r\n          reject(new Error(`Worker error: ${error.message}`));\r\n        };\r\n\r\n        // Send request to worker\r\n        worker.postMessage({\r\n          type: \"fetchStylesheet\",\r\n          url: firstStylesheet.href,\r\n        } as WorkerFetchStylesheetRequest);\r\n      }\r\n    );\r\n\r\n    // Map the results back to the elements\r\n    for (const [className, matchingElements] of elementClassMap.entries()) {\r\n      const cssProps = classRulesMap[className] || {};\r\n\r\n      for (const element of matchingElements) {\r\n        result.set(element, { ...cssProps });\r\n      }\r\n    }\r\n  } catch (e) {\r\n    console.error(\"Error in worker processing:\", e);\r\n  } finally {\r\n    // Always terminate the worker\r\n    worker.terminate();\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Extracts Webflow variable modes from elements with data-variable-mode attribute.\r\n * Uses caching based on the site's publish date.\r\n */\r\nconst extractWebflowVariableModes = async (): Promise<VariableModes | null> => {\r\n  // Get the current site publish date\r\n  const currentPublishDate = getWfPublishDate();\r\n  const publishDateString = currentPublishDate?.toISOString() || \"\";\r\n\r\n  // Try to get cached data\r\n  try {\r\n    const cachedData = localStorage.getItem(CACHE_KEY) || null;\r\n\r\n    if (cachedData && currentPublishDate) {\r\n      const parsedCache = JSON.parse(cachedData) as CachedVariableModes;\r\n\r\n      // If the publish date matches, use cached data\r\n      if (parsedCache.publishDate === publishDateString) {\r\n        console.debug(\"Using cached variable modes from\", publishDateString);\r\n        return parsedCache.data;\r\n      }\r\n    }\r\n  } catch (e) {\r\n    console.error(\"Error accessing localStorage cache:\", e);\r\n  }\r\n\r\n  // If no cache or invalid cache, calculate fresh data\r\n  console.debug(\"Calculating fresh variable modes data\");\r\n\r\n  const variableModeElements = getMultipleHtmlElements({ selector: \"[data-variable-mode]\" });\r\n\r\n  if (!variableModeElements) return null;\r\n\r\n  // Await the async extraction function\r\n  const result = await extractCssCustomProperties(variableModeElements);\r\n\r\n  const variableModes: VariableModes = {};\r\n\r\n  for (const variableModeElement of variableModeElements) {\r\n    const modeName = variableModeElement.dataset.variableMode;\r\n    if (!modeName) continue;\r\n\r\n    const variables = result.get(variableModeElement);\r\n    if (!variables) continue;\r\n    variableModes[modeName] = variables;\r\n  }\r\n\r\n  // Cache the result with current publish date\r\n  if (currentPublishDate) {\r\n    try {\r\n      const cacheData: CachedVariableModes = {\r\n        publishDate: publishDateString,\r\n        data: variableModes,\r\n      };\r\n\r\n      localStorage.setItem(CACHE_KEY, JSON.stringify(cacheData));\r\n    } catch (e) {\r\n      console.error(\"Error caching variable modes:\", e);\r\n    }\r\n  }\r\n\r\n  return variableModes;\r\n};\r\n\r\n// Initialize the global object\r\nwindow.wfVarModes = {\r\n  data: null,\r\n  isReady: false,\r\n};\r\n\r\n// Initialize variable modes and dispatch event\r\nconst initWfVarModes = async (): Promise<void> => {\r\n  // Extract the variable modes (await the async function)\r\n  const variableModes = await extractWebflowVariableModes();\r\n\r\n  if (!variableModes) {\r\n    console.error(\r\n      \"No injected variable modes found with [data-variable-mode] or extraction failed.\"\r\n    );\r\n    return;\r\n  }\r\n\r\n  // Update the global object\r\n  if (!window.wfVarModes) return;\r\n\r\n  window.wfVarModes.data = variableModes;\r\n  window.wfVarModes.isReady = true;\r\n\r\n  // Dispatch the ready event with data\r\n  window.dispatchEvent(\r\n    new CustomEvent(\"wfVarModesReady\", {\r\n      detail: { data: variableModes },\r\n    })\r\n  );\r\n\r\n  console.debug(\"WF Variable Modes ready:\", variableModes);\r\n};\r\n\r\n// Run initialization asynchronously\r\n(async () => {\r\n  await initWfVarModes();\r\n})();\r\n"],
  "mappings": "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",
  "names": []
}
