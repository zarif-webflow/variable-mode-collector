{
  "version": 3,
  "sources": ["../bin/live-reload.js", "../node_modules/.pnpm/@finsweet+ts-utils@0.40.0/node_modules/@finsweet/ts-utils/dist/webflow/getPublishDate.js", "../src/utils/get-html-element.ts", "../src/features/wf-variable-mode-collector.ts"],
  "sourcesContent": ["new EventSource(`${SERVE_ORIGIN}/esbuild`).addEventListener(\"change\", () => location.reload());\n", "/**\n * Extracts the publish date of a Webflow site\n * @returns A Date object, if found.\n * @param page The page to get the publish date from. Defaults to the current page.\n */\nexport const getPublishDate = (page = document) => {\n    const publishDatePrefix = 'Last Published:';\n    for (const node of page.childNodes) {\n        if (node.nodeType === Node.COMMENT_NODE && node.textContent?.includes(publishDatePrefix)) {\n            const publishDateValue = node.textContent.trim().split(publishDatePrefix)[1];\n            if (publishDateValue)\n                return new Date(publishDateValue);\n        }\n    }\n};\n", "/**\r\n * Configuration options for HTML element selection utilities.\r\n */\r\ntype GetHtmlElementProps = {\r\n  /** CSS selector string to target the desired element(s) */\r\n  selector: string;\r\n  /** Optional parent element to scope the search within. Defaults to document if not provided */\r\n  parent?: HTMLElement;\r\n  /** Logging level for when elements are not found. Set to false to disable logging */\r\n  log?: \"debug\" | \"error\" | false;\r\n};\r\n\r\n/**\r\n * Safely retrieves a single HTML element using a CSS selector with optional logging.\r\n *\r\n * @template TElement - The specific HTML element type to return (extends HTMLElement)\r\n * @param options - Configuration object for element selection\r\n * @param options.selector - CSS selector string to target the desired element\r\n * @param options.parent - Optional parent element to scope the search within\r\n * @param options.log - Logging level when element is not found (\"debug\", \"error\", or false)\r\n * @returns The found HTML element cast to the specified type, or null if not found\r\n *\r\n * @example\r\n * ```typescript\r\n * // Get a button element with error logging\r\n * const button = getHtmlElement<HTMLButtonElement>({\r\n *   selector: '.submit-btn',\r\n *   log: 'error'\r\n * });\r\n *\r\n * // Get an element within a specific parent with debug logging\r\n * const input = getHtmlElement<HTMLInputElement>({\r\n *   selector: 'input[type=\"email\"]',\r\n *   parent: formElement,\r\n *   log: 'debug'\r\n * });\r\n *\r\n * // Silent mode - no logging\r\n * const element = getHtmlElement({\r\n *   selector: '.optional-element',\r\n *   log: false\r\n * });\r\n * ```\r\n */\r\nexport const getHtmlElement = <TElement extends HTMLElement = HTMLElement>({\r\n  selector,\r\n  parent,\r\n  log = \"debug\",\r\n}: GetHtmlElementProps): TElement | null => {\r\n  const targetElement = (parent || document).querySelector<TElement>(selector);\r\n\r\n  if (targetElement === null) {\r\n    if (log === false) return null;\r\n    const consoleMethod = log === \"debug\" ? console.debug : console.error;\r\n    consoleMethod(\r\n      `${log.toUpperCase()}: Element with selector \"${selector}\" not found in ${\r\n        parent !== undefined ? \"the specified parent element:\" : \"the document.\"\r\n      }`,\r\n      parent\r\n    );\r\n    return null;\r\n  }\r\n\r\n  return targetElement;\r\n};\r\n\r\n/**\r\n * Safely retrieves multiple HTML elements using a CSS selector with optional logging.\r\n *\r\n * @template TElement - The specific HTML element type for array items (extends HTMLElement)\r\n * @param options - Configuration object for element selection\r\n * @param options.selector - CSS selector string to target the desired elements\r\n * @param options.parent - Optional parent element to scope the search within\r\n * @param options.log - Logging level when no elements are found (\"debug\", \"error\", or false)\r\n * @returns Array of found HTML elements cast to the specified type, or null if none found\r\n *\r\n * @example\r\n * ```typescript\r\n * // Get all list items with debug logging\r\n * const listItems = getMultipleHtmlElements<HTMLLIElement>({\r\n *   selector: 'li.item',\r\n *   log: 'debug'\r\n * });\r\n *\r\n * // Get all inputs within a form with error logging\r\n * const inputs = getMultipleHtmlElements<HTMLInputElement>({\r\n *   selector: 'input',\r\n *   parent: formElement,\r\n *   log: 'error'\r\n * });\r\n *\r\n * // Silent mode - no logging when elements not found\r\n * const buttons = getMultipleHtmlElements<HTMLButtonElement>({\r\n *   selector: '.action-btn',\r\n *   log: false\r\n * });\r\n * ```\r\n */\r\nexport const getMultipleHtmlElements = <TElement extends HTMLElement = HTMLElement>({\r\n  selector,\r\n  parent,\r\n  log = \"debug\",\r\n}: GetHtmlElementProps): TElement[] | null => {\r\n  const targetElements = Array.from((parent || document).querySelectorAll<TElement>(selector));\r\n\r\n  if (targetElements.length === 0) {\r\n    if (log === false) return null;\r\n    const consoleMethod = log === \"debug\" ? console.debug : console.error;\r\n    consoleMethod(\r\n      `${log.toUpperCase()}: No elements found with selector \"${selector}\" in ${\r\n        parent !== undefined ? \"the specified parent element:\" : \"the document.\"\r\n      }`,\r\n      parent\r\n    );\r\n    return null;\r\n  }\r\n\r\n  return targetElements;\r\n};\r\n", "import { getPublishDate as getWfPublishDate } from \"@finsweet/ts-utils\";\r\n\r\nimport { getMultipleHtmlElements } from \"@/utils/get-html-element\";\r\n\r\n/**\r\n * Extracts CSS custom properties (variables) applied to multiple elements from their classes.\r\n * This function assumes each element has exactly one class that contains all its styling.\r\n * Only extracts properties that start with '--' (CSS variables).\r\n * The stylesheet is fetched and parsed once for efficiency.\r\n *\r\n * @param elements Array of target HTML elements\r\n * @returns A Promise resolving to a Map associating each element with its CSS custom properties\r\n */\r\nasync function extractCssCustomProperties(\r\n  elements: HTMLElement[]\r\n): Promise<Map<HTMLElement, Record<string, string>>> {\r\n  // Initialize result map\r\n  const result = new Map<HTMLElement, Record<string, string>>();\r\n\r\n  // Find the first loaded stylesheet\r\n  const firstStylesheet = document.styleSheets[0];\r\n  if (!firstStylesheet || !firstStylesheet.href) {\r\n    // Return empty map if no stylesheets or no href\r\n    return result;\r\n  }\r\n\r\n  // Create a map to store class-to-CSS-properties mapping\r\n  const classRulesMap = new Map<string, Record<string, string>>();\r\n\r\n  try {\r\n    // Fetch the stylesheet directly instead of accessing through DOM\r\n    const stylesheetUrl = firstStylesheet.href;\r\n    const response = await fetch(stylesheetUrl);\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to fetch stylesheet: ${response.status} ${response.statusText}`);\r\n    }\r\n\r\n    const cssText = await response.text();\r\n\r\n    // Parse the CSS text using regex to find class selectors and their properties\r\n    const classRegex = /\\.([^\\s{,:]+)\\s*{([^}]*)}/g;\r\n    let match;\r\n\r\n    while ((match = classRegex.exec(cssText)) !== null) {\r\n      const className = match[1];\r\n      const styleBlock = match[2];\r\n\r\n      if (!className || !styleBlock) continue;\r\n\r\n      // Extract CSS variables\r\n      const variableRegex = /(--[^:]+):\\s*([^;]+);/g;\r\n      let varMatch;\r\n      const customProps: Record<string, string> = {};\r\n\r\n      while ((varMatch = variableRegex.exec(styleBlock)) !== null) {\r\n        const propName = varMatch[1]!.trim();\r\n        const propValue = varMatch[2]!.trim();\r\n        customProps[propName] = propValue;\r\n      }\r\n\r\n      // Store the results in the class map if any CSS variables were found\r\n      if (Object.keys(customProps).length > 0) {\r\n        classRulesMap.set(className, customProps);\r\n      }\r\n    }\r\n\r\n    // Process each element\r\n    for (const element of elements) {\r\n      // Set default empty object for this element\r\n      const elementRules: Record<string, string> = {};\r\n      result.set(element, elementRules);\r\n\r\n      // Skip elements without classes\r\n      if (!element.classList.length) {\r\n        continue;\r\n      }\r\n\r\n      const className = element.classList[0]!; // Get the first class\r\n\r\n      // Check if we've already processed this class\r\n      if (classRulesMap.has(className)) {\r\n        // Reuse the cached rules\r\n        result.set(element, { ...classRulesMap.get(className)! });\r\n      }\r\n    }\r\n  } catch (e) {\r\n    console.error(\"Error fetching or parsing stylesheet:\", e);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n// Cache interface\r\ninterface CachedVariableModes {\r\n  publishDate: string;\r\n  data: VariableModes;\r\n}\r\n\r\nconst CACHE_KEY = \"webflow-variable-modes-cache\";\r\n\r\n// Global interface for wfVarModes\r\ninterface WfVarModesObject {\r\n  data: VariableModes | null;\r\n  isReady: boolean;\r\n  onReady: (callback: (data: VariableModes) => void) => void;\r\n}\r\n\r\n// Initialize global object\r\ndeclare global {\r\n  interface Window {\r\n    wfVarModes: WfVarModesObject;\r\n  }\r\n}\r\n\r\n// Initialize the global object\r\nwindow.wfVarModes = {\r\n  data: null,\r\n  isReady: false,\r\n  onReady(callback) {\r\n    if (this.isReady && this.data) {\r\n      // If data is already loaded, execute callback immediately\r\n      setTimeout(() => callback(this.data!), 0);\r\n    } else {\r\n      // Otherwise, add event listener\r\n      window.addEventListener(\"wfVarModesReady\", () => callback(this.data!));\r\n    }\r\n  },\r\n};\r\n\r\nconst extractWebflowVariableModes = async (): Promise<VariableModes | null> => {\r\n  // Get the current site publish date\r\n  const currentPublishDate = getWfPublishDate();\r\n  const publishDateString = currentPublishDate?.toISOString() || \"\";\r\n\r\n  // Try to get cached data\r\n  try {\r\n    const cachedData = localStorage.getItem(CACHE_KEY);\r\n\r\n    if (cachedData && currentPublishDate) {\r\n      const parsedCache = JSON.parse(cachedData) as CachedVariableModes;\r\n\r\n      // If the publish date matches, use cached data\r\n      if (parsedCache.publishDate === publishDateString) {\r\n        console.debug(\"Using cached variable modes from\", publishDateString);\r\n        return parsedCache.data;\r\n      }\r\n    }\r\n  } catch (e) {\r\n    console.error(\"Error accessing localStorage cache:\", e);\r\n  }\r\n\r\n  // If no cache or invalid cache, calculate fresh data\r\n  console.debug(\"Calculating fresh variable modes data\");\r\n\r\n  const variableModeElements = getMultipleHtmlElements({ selector: \"[data-variable-mode]\" });\r\n\r\n  if (!variableModeElements) return null;\r\n\r\n  // Await the async extraction function\r\n  const result = await extractCssCustomProperties(variableModeElements);\r\n\r\n  const variableModes: VariableModes = {};\r\n\r\n  for (const variableModeElement of variableModeElements) {\r\n    const modeName = variableModeElement.dataset.variableMode;\r\n    if (!modeName) continue;\r\n\r\n    const variables = result.get(variableModeElement);\r\n    if (!variables) continue;\r\n    variableModes[modeName] = variables;\r\n  }\r\n\r\n  // Cache the result with current publish date\r\n  if (currentPublishDate) {\r\n    try {\r\n      const cacheData: CachedVariableModes = {\r\n        publishDate: publishDateString,\r\n        data: variableModes,\r\n      };\r\n\r\n      localStorage.setItem(CACHE_KEY, JSON.stringify(cacheData));\r\n    } catch (e) {\r\n      console.error(\"Error caching variable modes:\", e);\r\n    }\r\n  }\r\n\r\n  return variableModes;\r\n};\r\n\r\n// Initialize variable modes and dispatch event\r\nconst initWfVarModes = async (): Promise<void> => {\r\n  // Extract the variable modes (await the async function)\r\n  const variableModes = await extractWebflowVariableModes();\r\n\r\n  if (!variableModes) {\r\n    console.error(\r\n      \"No injected variable modes found with [data-variable-mode] or extraction failed.\"\r\n    );\r\n    return;\r\n  }\r\n\r\n  // Update the global object\r\n  window.wfVarModes.data = variableModes;\r\n  window.wfVarModes.isReady = true;\r\n\r\n  // Dispatch the ready event\r\n  window.dispatchEvent(new CustomEvent(\"wfVarModesReady\"));\r\n\r\n  console.debug(\"WF Variable Modes ready:\", variableModes);\r\n};\r\n\r\n// Run initialization asynchronously\r\n(async () => {\r\n  await initWfVarModes();\r\n})();\r\n"],
  "mappings": "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",
  "names": []
}
